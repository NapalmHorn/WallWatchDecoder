#  wall_watcher_dd_wrt_log_reader.py

import sys


class log_report(object):

    def __init__(self):
        self.domains = {}
        self.sortkey = 'remote_ip'
        self.good_keys = ['date', 'time', 'code', 'protocol', 'remote_ip',
            'remote_domain', 'remote_port', 'local_ip', 'local_port']
        self.data_scope = []  # if we only report cretian data points

    def add(self, entry_line):
        #if we have resricted scope, is it in that restriction
        if self.__filter(entry_line):
            if entry_line.get(self.sortkey) in self.domains.keys():
                # if we already have found one like this increase the count
                self.domains[entry_line.get(self.sortkey)] += 1
            else:
                # if we have not found one like this, start a new count at 1
                self.domains[entry_line.get(self.sortkey)] = 1


    def __filter(self, entry_line):
        if not self.data_scope:
            return True
        else:
            for rule in self.data_scope:
                if entry_line.get(rule[0]) != rule[1]:
                    # the data point does not met this rule
                    return False
            return True  # if we got here th


    def setSortKey(self, key):
        """ Sets the key to which we sort the data"""
        if key in self.good_keys:
            self.sortkey = key
        else:
            print("Key must be one of following:")
            for k in self.line_dict.keys():
                print(k,)

    def setScope(self, values):
        """ only look at data points where key is in the values list
        should be a list of tuples of the form (key, value)"""
        if not isinstance(values, list):
            values = [str(values)]
        self.data_scope = values

    def report(self, max_report_size=10):
        def lastest(a): return a[-1]
        top_domains = []
        for a in self.domains.keys():
            top_domains.append((a, self.domains[a]))

        #Sort the list for the report
        top_domains = sorted(top_domains, key=lastest, reverse=True)

        # print out the largest 10 or so entries
        for n in range(min(max_report_size, len(self.domains))):
            a, b = top_domains.pop(0)
            print('Rank:' + str(n + 1)  + ' Addr: ' + str(a) + ' hits:' +
                str(b))


class entry(object):

    def __init__(self, line):
        self.line_dict = {}
        # split log line
        # Generated by wallwatcher for dd-wrt
        #  its tab serpartated
        line_data = line.split('\t')

        self.line_dict['date'] = line_data.pop(0)
        self.line_dict['time'] = line_data.pop(0)
        self.line_dict['code'] = line_data.pop(0)
        self.line_dict['protocol'] = line_data.pop(0)
        self.line_dict['remote_ip'] = line_data.pop(0)
        self.line_dict['remote_domain'] = line_data.pop(0)
        self.line_dict['remote_port'] = line_data.pop(0)
        self.line_dict['local_ip'] = line_data.pop(0)
        self.line_dict['local_port'] = line_data.pop(0)


    def get(self,item):
        """ Returns data for a key """
        if not item in self.line_dict.keys():
            print("No such data in entry.  Good keys are:")
            for k in self.line_dict.keys():
                print(k,)
            return None
        else:
            return self.line_dict[item]





def main():
    # figure out which files to read
    # load files data smartly into a dictionary

    filename = sys.argv[1]
    f = open(filename, 'r')
    lines = f.readlines()
    f.close()
    log = log_report()

    #configure log here
    values = []
    values.append(('local_ip', '10.19.19.108'))
    values.append(('remote_port', '443'))
    log.setScope(values)

    for line in lines:
        entry_line = entry(line)
        log.add(entry_line)

    log.report()


if __name__ == '__main__':
    main()