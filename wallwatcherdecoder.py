#  wallwatcherdecoder.py

import sys


class log_report(object):

    def __init__(self):
        self.domains = {}
        self.sortkey = 'remote_ip'
        self.good_keys = ['date', 'time', 'code', 'protocol', 'remote_ip',
            'remote_domain', 'remote_port', 'local_ip', 'local_port']
        self.data_scope = []  # if we only report cretian data points

    def add(self, entry_line):
        #if we have resricted scope, is it in that restriction
        if self.__filter(entry_line):
            if entry_line.get(self.sortkey) in self.domains.keys():
                # if we already have found one like this increase the count
                self.domains[entry_line.get(self.sortkey)] += 1
            else:
                # if we have not found one like this, start a new count at 1
                self.domains[entry_line.get(self.sortkey)] = 1

    def __filter(self, entry_line):
        """__filter is not intended to be called directly this filters entries
        as they are added based on values requirements"""
        if not self.data_scope:
            return True
        else:
            for rule in self.data_scope:
                if entry_line.get(rule[0]) != rule[1]:
                    # the data point does not met this rule
                    return False
            return True  # if we got here th

    def setSortKey(self, key):
        """ Sets the key to which we sort the data"""
        if key in self.good_keys:
            self.sortkey = key
        else:
            print("Key must be one of following:")
            for k in self.line_dict.keys():
                print(k,)

    def setScope(self, values):
        """ only look at data points where key is in the values list
        should be a list of tuples of the form (key, value)"""
        if not isinstance(values, list):
            values = [str(values)]
        self.data_scope = values

    def report(self, max_report_size=10):
        """ Prints a report of at most the top 10 (or report size) domains
        in terms of hits, that met the filter.
        """
        def lastest(a):
            return a[-1]
        top_domains = []
        for a in self.domains.keys():
            top_domains.append((a, self.domains[a]))

        #Sort the list for the report
        top_domains = sorted(top_domains, key=lastest, reverse=True)

        # print out the largest 10 or so entries
        for n in range(min(max_report_size, len(self.domains))):
            a, b = top_domains.pop(0)
            print(('Rank:' + str(n + 1) + ', "' + self.sortkey + '" :' +
             str(a) + ', hits:' + str(b)))

    def write_csv(self, outfile):
        """TODO write a simple data dump to a csv file"""
        def lastest(a):
            return a[-1]
        top_domains = []
        for a in self.domains.keys():
            top_domains.append((a, self.domains[a]))

        #Sort the list for the report
        top_domains = sorted(top_domains, key=lastest, reverse=True)
        f = open(outfile, 'w')
        f.write(self.sortkey + ', ' + 'hits\n')
        # print out the largest 10 or so entries
        for n in range(len(self.domains)):
            a, b = top_domains.pop(0)
            f.write('\n' + a + ', ' + str(b))


class entry(object):

    def __init__(self, line):
        self.line_dict = {}
        # split log line
        # Generated by wallwatcher for dd-wrt
        #  its tab serpartated
        line_data = line.split('\t')

        self.line_dict['date'] = line_data.pop(0)
        self.line_dict['time'] = line_data.pop(0)
        self.line_dict['code'] = line_data.pop(0)
        self.line_dict['protocol'] = line_data.pop(0)
        self.line_dict['remote_ip'] = line_data.pop(0)
        self.line_dict['remote_domain'] = line_data.pop(0)
        self.line_dict['remote_port'] = line_data.pop(0)
        self.line_dict['local_ip'] = line_data.pop(0)
        self.line_dict['local_port'] = line_data.pop(0)

    def get(self, item):
        """ Returns data for a key """
        if not item in self.line_dict.keys():
            print("No such data in entry.  Good keys are:")
            for k in self.line_dict.keys():
                print(k,)
            return None
        else:
            return self.line_dict[item]


def print_values(values):
    """Prints out the rules for the filter"""
    for rule in values:
        print("\"{0}\" must be \"{1}\"".format(rule[0], rule[1]))


def getArgv():
    infiles = []
    outfile = ''
    args = sys.argv
    current = args.pop(0)  # the first one in interpreter or script name
    # process each options
    while args:
        current = args.pop(0)
        if 'wallwatcherdecoder.py' in current:
            None
        elif current == '--outfile':
            outfile = args.pop(0)
        elif current == '--infiles':
            filename = args.pop(0)
            while filename[:2] != '--' and args:

                infiles.append(filename)
                filename = args.pop(0)
            if filename[:2] == '--':
                args = [filename] + args  # readd the option that was popped
        else:
            print("Useage:python wallwatcher.py infile ")
            print("\nOR\n")
            print('Useage:python wallwatcher.py --infiles infile1 infile2 ' +
                       "[...] [--outfile outfile.csv]")
            print("\nOR\n")
            print("--help")
            sys.exit(0)

    return infiles, outfile


def main():
    # figure out which files to read
    # load files data smartly into a dictionary

    if len(sys.argv) == 2:
        filename = sys.argv[1]
        f = open(filename, 'r')
        lines = f.readlines()
        f.close()
    elif len(sys.argv) > 2:
        infiles, outfile = getArgv()
        lines = []
        for filename in infiles:
            f = open(filename, 'r')
            lines += f.readlines()
            f.close()
    else:
        print("Useage:python wallwatcher.py infile ")
        print("\nOR\n")
        print('Useage:python wallwatcher.py --infiles infile1 infile2 [...]' +
        "[--outfile outfile.csv]")
        print("\nOR\n")
        print("--help")
        sys.exit(0)
    log = log_report()

    #configure log here, 2 examples included
    values = []
    #values.append(('local_ip', '10.19.19.109'))
    values.append(('remote_port', '80'))
    log.setScope(values)

    log.setSortKey('local_ip')

    for line in lines:
        entry_line = entry(line)
        log.add(entry_line)
    print_values(values)
    log.report()
    if outfile:
        log.write_csv(outfile)


if __name__ == '__main__':
    main()